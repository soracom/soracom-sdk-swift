//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public final class InsertBeamStatsRequest: Codable, Equatable {

    public var beamStatsMap: BeamStatsMap?

    /** UNIX 時刻（ミリ秒単位） */
    public var unixtime: Int?

    public final class BeamStatsMap: Codable, Equatable {

        public var inHttp: BeamCounts?

        public var inMqtt: BeamCounts?

        public var inTcp: BeamCounts?

        public var inUdp: BeamCounts?

        public var outHttp: BeamCounts?

        public var outHttps: BeamCounts?

        public var outMqtt: BeamCounts?

        public var outMqtts: BeamCounts?

        public var outTcp: BeamCounts?

        public var outTcps: BeamCounts?

        public var outUdp: BeamCounts?

        public init(inHttp: BeamCounts? = nil, inMqtt: BeamCounts? = nil, inTcp: BeamCounts? = nil, inUdp: BeamCounts? = nil, outHttp: BeamCounts? = nil, outHttps: BeamCounts? = nil, outMqtt: BeamCounts? = nil, outMqtts: BeamCounts? = nil, outTcp: BeamCounts? = nil, outTcps: BeamCounts? = nil, outUdp: BeamCounts? = nil) {
            self.inHttp = inHttp
            self.inMqtt = inMqtt
            self.inTcp = inTcp
            self.inUdp = inUdp
            self.outHttp = outHttp
            self.outHttps = outHttps
            self.outMqtt = outMqtt
            self.outMqtts = outMqtts
            self.outTcp = outTcp
            self.outTcps = outTcps
            self.outUdp = outUdp
        }

        private enum CodingKeys: String, CodingKey {
            case inHttp
            case inMqtt
            case inTcp
            case inUdp
            case outHttp
            case outHttps
            case outMqtt
            case outMqtts
            case outTcp
            case outTcps
            case outUdp
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            inHttp = try container.decodeIfPresent(.inHttp)
            inMqtt = try container.decodeIfPresent(.inMqtt)
            inTcp = try container.decodeIfPresent(.inTcp)
            inUdp = try container.decodeIfPresent(.inUdp)
            outHttp = try container.decodeIfPresent(.outHttp)
            outHttps = try container.decodeIfPresent(.outHttps)
            outMqtt = try container.decodeIfPresent(.outMqtt)
            outMqtts = try container.decodeIfPresent(.outMqtts)
            outTcp = try container.decodeIfPresent(.outTcp)
            outTcps = try container.decodeIfPresent(.outTcps)
            outUdp = try container.decodeIfPresent(.outUdp)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(inHttp, forKey: .inHttp)
            try container.encodeIfPresent(inMqtt, forKey: .inMqtt)
            try container.encodeIfPresent(inTcp, forKey: .inTcp)
            try container.encodeIfPresent(inUdp, forKey: .inUdp)
            try container.encodeIfPresent(outHttp, forKey: .outHttp)
            try container.encodeIfPresent(outHttps, forKey: .outHttps)
            try container.encodeIfPresent(outMqtt, forKey: .outMqtt)
            try container.encodeIfPresent(outMqtts, forKey: .outMqtts)
            try container.encodeIfPresent(outTcp, forKey: .outTcp)
            try container.encodeIfPresent(outTcps, forKey: .outTcps)
            try container.encodeIfPresent(outUdp, forKey: .outUdp)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? BeamStatsMap else { return false }
          guard self.inHttp == object.inHttp else { return false }
          guard self.inMqtt == object.inMqtt else { return false }
          guard self.inTcp == object.inTcp else { return false }
          guard self.inUdp == object.inUdp else { return false }
          guard self.outHttp == object.outHttp else { return false }
          guard self.outHttps == object.outHttps else { return false }
          guard self.outMqtt == object.outMqtt else { return false }
          guard self.outMqtts == object.outMqtts else { return false }
          guard self.outTcp == object.outTcp else { return false }
          guard self.outTcps == object.outTcps else { return false }
          guard self.outUdp == object.outUdp else { return false }
          return true
        }

        public static func == (lhs: BeamStatsMap, rhs: BeamStatsMap) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(beamStatsMap: BeamStatsMap? = nil, unixtime: Int? = nil) {
        self.beamStatsMap = beamStatsMap
        self.unixtime = unixtime
    }

    private enum CodingKeys: String, CodingKey {
        case beamStatsMap
        case unixtime
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        beamStatsMap = try container.decodeIfPresent(.beamStatsMap)
        unixtime = try container.decodeIfPresent(.unixtime)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(beamStatsMap, forKey: .beamStatsMap)
        try container.encodeIfPresent(unixtime, forKey: .unixtime)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? InsertBeamStatsRequest else { return false }
      guard self.beamStatsMap == object.beamStatsMap else { return false }
      guard self.unixtime == object.unixtime else { return false }
      return true
    }

    public static func == (lhs: InsertBeamStatsRequest, rhs: InsertBeamStatsRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
