//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public final class ResourceInstance: Codable, Equatable {

    public enum Operations: String, Codable {
        case none = "NONE"
        case r = "R"
        case w = "W"
        case rw = "RW"
        case e = "E"
        case re = "RE"
        case we = "WE"
        case rwe = "RWE"

        public static let cases: [Operations] = [
          .none,
          .r,
          .w,
          .rw,
          .e,
          .re,
          .we,
          .rwe,
        ]
    }

    public enum `Type`: String, Codable {
        case string = "STRING"
        case integer = "INTEGER"
        case float = "FLOAT"
        case boolean = "BOOLEAN"
        case opaque = "OPAQUE"
        case time = "TIME"
        case objlnk = "OBJLNK"

        public static let cases: [`Type`] = [
          .string,
          .integer,
          .float,
          .boolean,
          .opaque,
          .time,
          .objlnk,
        ]
    }

    public var description: String?

    public var id: Int?

    public var mandatory: Bool?

    public var multiple: Bool?

    public var name: String?

    public var observed: Bool?

    public var operations: Operations?

    public var rangeEnumeration: String?

    public var type: `Type`?

    public var units: String?

    public var value: [String: Any]?

    public var values: [String: Any]?

    public init(description: String? = nil, id: Int? = nil, mandatory: Bool? = nil, multiple: Bool? = nil, name: String? = nil, observed: Bool? = nil, operations: Operations? = nil, rangeEnumeration: String? = nil, type: `Type`? = nil, units: String? = nil, value: [String: Any]? = nil, values: [String: Any]? = nil) {
        self.description = description
        self.id = id
        self.mandatory = mandatory
        self.multiple = multiple
        self.name = name
        self.observed = observed
        self.operations = operations
        self.rangeEnumeration = rangeEnumeration
        self.type = type
        self.units = units
        self.value = value
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case id
        case mandatory
        case multiple
        case name
        case observed
        case operations
        case rangeEnumeration
        case type
        case units
        case value
        case values
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        description = try container.decodeIfPresent(.description)
        id = try container.decodeIfPresent(.id)
        mandatory = try container.decodeIfPresent(.mandatory)
        multiple = try container.decodeIfPresent(.multiple)
        name = try container.decodeIfPresent(.name)
        observed = try container.decodeIfPresent(.observed)
        operations = try container.decodeIfPresent(.operations)
        rangeEnumeration = try container.decodeIfPresent(.rangeEnumeration)
        type = try container.decodeIfPresent(.type)
        units = try container.decodeIfPresent(.units)
        value = try container.decodeAnyIfPresent(.value)
        values = try container.decodeAnyIfPresent(.values)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(mandatory, forKey: .mandatory)
        try container.encodeIfPresent(multiple, forKey: .multiple)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(observed, forKey: .observed)
        try container.encodeIfPresent(operations, forKey: .operations)
        try container.encodeIfPresent(rangeEnumeration, forKey: .rangeEnumeration)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(units, forKey: .units)
        try container.encodeAnyIfPresent(value, forKey: .value)
        try container.encodeAnyIfPresent(values, forKey: .values)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ResourceInstance else { return false }
      guard self.description == object.description else { return false }
      guard self.id == object.id else { return false }
      guard self.mandatory == object.mandatory else { return false }
      guard self.multiple == object.multiple else { return false }
      guard self.name == object.name else { return false }
      guard self.observed == object.observed else { return false }
      guard self.operations == object.operations else { return false }
      guard self.rangeEnumeration == object.rangeEnumeration else { return false }
      guard self.type == object.type else { return false }
      guard self.units == object.units else { return false }
      guard NSDictionary(dictionary: self.value ?? [:]).isEqual(to: object.value ?? [:]) else { return false }
      guard NSDictionary(dictionary: self.values ?? [:]).isEqual(to: object.values ?? [:]) else { return false }
      return true
    }

    public static func == (lhs: ResourceInstance, rhs: ResourceInstance) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
