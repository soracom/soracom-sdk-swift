//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

open class _GetPaymentMethodResult: Codable, Equatable {

    /** エラーコード（支払い情報が無効な場合のみ） */
    public enum ErrorCode: String, Codable {
        case success = "success"
        case processing = "processing"
        case invalidRequest = "invalid_request"
        case invalidNumber = "invalid_number"
        case incorrectNumber = "incorrect_number"
        case invalidName = "invalid_name"
        case invalidExpiryMonth = "invalid_expiry_month"
        case invalidExpiryYear = "invalid_expiry_year"
        case invalidExpiry = "invalid_expiry"
        case incorrectExpiry = "incorrect_expiry"
        case invalidCvc = "invalid_cvc"
        case incorrectCvc = "incorrect_cvc"
        case cardDeclined = "card_declined"
        case missing = "missing"
        case processingError = "processing_error"

        public static let cases: [ErrorCode] = [
          .success,
          .processing,
          .invalidRequest,
          .invalidNumber,
          .incorrectNumber,
          .invalidName,
          .invalidExpiryMonth,
          .invalidExpiryYear,
          .invalidExpiry,
          .incorrectExpiry,
          .invalidCvc,
          .incorrectCvc,
          .cardDeclined,
          .missing,
          .processingError,
        ]
    }

    /** 課金プロバイダ種別 */
    public enum ProviderType: String, Codable {
        case webPay = "WebPay"

        public static let cases: [ProviderType] = [
          .webPay,
        ]
    }

    /** エラーコード（支払い情報が無効な場合のみ） */
    open var errorCode: ErrorCode?

    /** エラーメッセージ（支払い情報が無効な場合のみ */
    open var errorMessage: String?

    /** 支払い情報 */
    open var properties: String?

    /** 課金プロバイダ種別 */
    open var providerType: ProviderType?

    /** 登録日 */
    open var updateDate: String?

    public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, properties: String? = nil, providerType: ProviderType? = nil, updateDate: String? = nil) {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.properties = properties
        self.providerType = providerType
        self.updateDate = updateDate
    }

    private enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case properties
        case providerType
        case updateDate
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        errorCode = try container.decodeIfPresent(.errorCode)
        errorMessage = try container.decodeIfPresent(.errorMessage)
        properties = try container.decodeIfPresent(.properties)
        providerType = try container.decodeIfPresent(.providerType)
        updateDate = try container.decodeIfPresent(.updateDate)
    }

    open func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(errorCode, forKey: .errorCode)
        try container.encodeIfPresent(errorMessage, forKey: .errorMessage)
        try container.encodeIfPresent(properties, forKey: .properties)
        try container.encodeIfPresent(providerType, forKey: .providerType)
        try container.encodeIfPresent(updateDate, forKey: .updateDate)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? _GetPaymentMethodResult else { return false }
      guard self.errorCode == object.errorCode else { return false }
      guard self.errorMessage == object.errorMessage else { return false }
      guard self.properties == object.properties else { return false }
      guard self.providerType == object.providerType else { return false }
      guard self.updateDate == object.updateDate else { return false }
      return true
    }

    public static func == (lhs: _GetPaymentMethodResult, rhs: _GetPaymentMethodResult) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
